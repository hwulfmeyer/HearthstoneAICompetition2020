using System.Linq;
using SabberStoneCore.Enums;
using SabberStoneBasicAI.Score;
using SabberStoneCore.Tasks.PlayerTasks;
using SabberStoneBasicAI.PartialObservation;
using System.Collections.Generic;
using SabberStoneCore.Model.Entities;
using SabberStoneCore.Model;
using System.IO;
using CsvHelper;
using System.Globalization;
using System.Diagnostics;
using System;

//Developed by Oskar Kirmis and Florian Koch and submitted to the 2018 Hearthstone AI Competition's Premade Deck Playing Track
namespace SabberStoneBasicAI.AIAgents.Learning
{
	// Plain old Greedy Bot
	class GreedyAgentv1 : AbstractAgent
	{
		List<List<float>> GameStateEncodes;
		private Dictionary<string, List<double>> CardClassScoreWeights;

		public override void InitializeAgent(){
			GameStateEncodes = new List<List<float>>();
			CardClassScoreWeights = new Dictionary<string, List<double>>();
			/*
			string[] classes = new string[] { "MAGE", "PALADIN", "ROGUE", "SHAMAN", "WARLOCK", "WARRIOR" };
			foreach (string cardclass in classes)
			{
				ProcessStartInfo start = new ProcessStartInfo();
				string cmd = "f:/load_model.py";
				start.FileName = "C:/Python38/python.exe";
				start.Arguments = String.Format("\"{0}\" \"{1}\"", cmd, "random_" + cardclass + "_Linear.pkl");
				start.UseShellExecute = false;// Do not use OS shell
				start.CreateNoWindow = true; // We don't need new window
				start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
				start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
				string result;
				using (Process process = Process.Start(start))
				{
					process.WaitForExit();
					using (StreamReader reader = process.StandardOutput)
					{
						string stderr = process.StandardError.ReadToEnd(); // Here are the exceptions from our Python script
						result = reader.ReadToEnd(); // Here is the result of StdOut(for example: print "test")
						string[] charsToRemove = new string[] { "[", "]", "\n", "\r" };
						foreach (string c in charsToRemove)
						{
							result = result.Replace(c, String.Empty);
						}
						string[] results = result.Split(", ");
						List<float> weights = new List<float>();
						foreach (string c in results)
						{
							weights.Add(Single.Parse(c, CultureInfo.InvariantCulture.NumberFormat));
						}
						CardClassScoreWeights.Add(cardclass, weights);
					}
				}
			}*/
			List<double> weights;
			weights = new List<double>() { 0.5359265974980221, 0.5163114233409954, 0.5485197719199845, 0.36123494163762654, -0.21254228460373295, 0.5522279027745877, 0.4465726654204785, 0.03168684515790007, 0.0903130984503714, 0.05893754159218277, -0.05247681717627896, -0.2762670765145196, 2.220446049250313e-16, -0.4694207080901187, -0.5568169453139014, -0.329092032650898, -0.622984809108873, 0.011381852158929881, -0.3897472450688495, -0.1736767723473775, 1.2356281332081898, -0.2057357115189894, -0.20461946974514122, -0.23562925347201877, 0.21011411382216533, -0.09555381413527705 };
			CardClassScoreWeights.Add("MAGE", weights);
			
			weights = new List<double>() { 1.321582909813508, 0.6600234757994029, 0.07225337308226192, 0.3561532123238372, -0.07002814761078717, 0.4344872454067603, 0.30904167100833185, -0.7668000749550619, 0.1958134754406109, -0.07125321071290065, 0.06617582988919406, -0.3438359959554716, -0.306619507390962, -1.1905019494484472, -0.626364769117593, -0.09048360350577073, -0.39328710690895535, -0.1421581309605943, -0.30728058792352486, -0.11973773788550268, 0.5971881063215135, -0.06337710274844065, -0.27731942594032427, -0.03777892829291099, 0.1628543031470663, 0.33132057484638794 };
			CardClassScoreWeights.Add("PALADIN", weights);
			
			weights = new List<double>() { 1.3876203341920617, 0.6855418703095606, 0.18742743185611296, 0.4906887561268414, -0.12333869465983191, 0.5159124416313647, 0.3926983492936258, 0.21796856129618436, 0.08085182303808995, 0.04484716131612132, 0.06305752445728835, -0.3279216689060969, -0.5415917183306147, -1.2893943429311692, -0.6575468268088345, -0.09945372614583294, -0.3741190285624961, -0.12587310944074598, -0.4123026856717087, -0.09327712393800808, -0.1126003422719337, -0.1078676393090936, -0.1783328015735798, -0.04399168593150808, 0.028893190158871117, 0.08138469777772873 };
			CardClassScoreWeights.Add("ROGUE", weights);
			
			weights = new List<double>() { 1.3163664743138574, 0.6651327294035738, 0.2463972255663899, 0.42981388952680394, -0.0933569491800495, 0.4351591004240116, 0.31840999368715955, -0.2573649316235434, 0.045889229358232066, 0.054270312055949614, 0.0650814253359627, -0.30796023550670243, -0.5837882373003719, -1.1936220559824027, -0.6431085559333698, -0.2534837210670258, -0.42955286490077516, -0.08744398565453504, -0.3349378848297718, -0.15917769808206944, 1.3454048744237146, -0.12043684008394678, -0.2090173070323826, -0.07235243255529863, 0.036022610903660095, -0.06855198536149777 };
			CardClassScoreWeights.Add("SHAMAN", weights);
			
			weights = new List<double>() { -0.36929655126930644, 0.6195265114650441, 0.37644732714902773, -0.3473474085909965, -0.27905516617519643, 0.5617859900728492, 0.6540797790317703, -0.6111236230733184, 0.9659898475574875, -0.025531931306625996, -0.10297637553664565, -0.29973176057855555, -1.7446150056431826, 0.8041461939090816, -0.7913046356317388, -1.2432428027740718, -0.8970806499900621, -0.05963308546005544, -0.320900059509135, 0.12312507414272451, -1.0651183230303507, 0.11421795612534447, -0.34690467646615253, -0.06142127398665819, 0.3580480567140461, -0.34033885014579923 };
			CardClassScoreWeights.Add("WARLOCK", weights);
			
			weights = new List<double>() { 1.0447011856371882, 0.6587007992995593, 0.16798267001151668, 0.3549776866337994, -0.06532101980092385, 0.4853443314615905, 0.3350045531749963, -0.23918898874607145, 0.2623023388691243, -0.006507861393080114, -0.034344842254078224, -0.2885405172610697, -0.5546237875880109, -0.8391187569387485, -0.6350423070848802, -0.08230853664135244, -0.35751329154159234, -0.13485235546171478, -0.44878052254615786, -0.20490992855935167, -0.15862403698242533, 0.21193396019532146, -0.09697862354296279, -0.0328743806291497, 0.20523344139941854, 0.24676682334538855 };
			CardClassScoreWeights.Add("WARRIOR", weights);


		}
		public override void InitializeGame() {}
		public override void FinalizeGame(Game game, Controller myPlayer)
		{
			bool write = false;
			bool test = true;

			if (write)
			{
				int GameResult = myPlayer.PlayState == PlayState.WON ? 1 : myPlayer.PlayState == PlayState.TIED ? 0 : -1;
				int GameResultHp = myPlayer.PlayState == PlayState.WON ? myPlayer.Hero.Health : myPlayer.PlayState == PlayState.TIED ? 0 : -myPlayer.Opponent.Hero.Health;

				for (int i = 0; i < GameStateEncodes.Count; i++)
				{
					GameStateEncodes[i].Add(GameResult);
					GameStateEncodes[i].Add(GameResultHp);
					GameStateEncodes[i].Add(GameResultHp * (GameStateEncodes[i][0] + 1) / 11.0f);
					GameStateEncodes[i].Add(GameResultHp * (i + 1.0f) / GameStateEncodes.Count);
				}

				bool success = false;	
				string folder = "F:\\data_" + (test ? "test" : "train") + "\\";
				while (!success)
				{
					try
					{
						using (FileStream fileStream = new FileStream(folder + "greedyv1_" + myPlayer.HeroClass.ToString() + ".csv", FileMode.Append, FileAccess.Write, FileShare.None))
						using (var writer = new StreamWriter(fileStream))
						{
							using (var csv = new CsvWriter(writer, CultureInfo.InvariantCulture))
							{
								foreach (List<float> record in GameStateEncodes)
								{
									foreach (float field in record)
									{
										csv.WriteField(field);
									}

									csv.NextRecord();
								}
								success = true;
							}
						}
					}
					catch
					{

					}
				}
			}
		}
		public override void FinalizeAgent() {}


		public override PlayerTask GetMove(POGame game)
		{
			float EPS = 0.0f;
			GameStateEncodes.Add(GameStateEncoding.GetEncoding(game, game.CurrentPlayer.PlayerId));
			Controller player = game.CurrentPlayer;

			// Implement a simple Mulligan Rule
			if (player.MulliganState == Mulligan.INPUT)
			{
				List<int> mulligan = new AggroScore().MulliganRule().Invoke(player.Choice.Choices.Select(p => game.getGame().IdEntityDic[p]).ToList());
				return ChooseTask.Mulligan(player, mulligan);
			}

			// Get all simulation results for simulations that didn't fail
			IEnumerable<KeyValuePair<PlayerTask, POGame>> validOpts = game.Simulate(player.Options()).Where(x => x.Value != null);

			// If all simulations failed, play end turn option (always exists), else best according to score function
			if (validOpts.Any())
			{
				Random rnd = new Random();
				if (rnd.NextDouble() >= EPS) return validOpts.OrderBy(x => Score(x.Value, player.PlayerId)).Last().Key;
				else return validOpts.ElementAt(rnd.Next(validOpts.Count())).Key;
			}
			else
			{
				return player.Options().First(x => x.PlayerTaskType == PlayerTaskType.END_TURN);
			}
		}

		// Calculate different scores based on our hero's class
		/*private static int Score(POGame state, int playerId)
		{
			var p = state.CurrentPlayer.PlayerId == playerId ? state.CurrentPlayer : state.CurrentOpponent;
			switch (state.CurrentPlayer.HeroClass)
			{
				case CardClass.WARRIOR: return new AggroScore { Controller = p }.Rate();
				case CardClass.MAGE: return new ControlScore { Controller = p }.Rate();
				default: return new RampScore { Controller = p }.Rate();
			}
		}*/

		private float Score(POGame state, int playerId)
		{
			Controller p = state.CurrentPlayer.PlayerId == playerId ? state.CurrentPlayer : state.CurrentOpponent;
			return new GameStateEncoding { Controller = p }.Rate(CardClassScoreWeights);
		}

		class GameStateEncoding : Score.Score
		{
			public int HeroClassId => (int)Controller.HeroClass;
			public int HeroArmor => Controller.Hero.Armor;
			public int HeroBaseMana => Controller.BaseMana;
			new public int MinionTotHealth => BoardZone.Sum(p => p.Health + p.Armor);
			new public int MinionTotHealthTaunt => BoardZone.Where(p => p.HasTaunt).Sum(p => p.Health + p.Armor);
			public int MinionTotHealthPoisonous => BoardZone.Where(p => p.Poisonous).Sum(p => p.Health + p.Armor);
			public int MinionWindfuryTotAtk => BoardZone.Where(p => p.HasWindfury).Sum(p => p.AttackDamage);
			public int MinionTotHealthDeathrattle => BoardZone.Where(p => p.HasDeathrattle).Sum(p => p.Health + p.Armor);
			public int MinionTotHealthDivineShield => BoardZone.Where(p => p.HasDivineShield).Sum(p => p.Health + p.Armor);
			public int MinionFrozenTotAtk => BoardZone.Where(p => p.IsFrozen).Sum(p => p.AttackDamage);
			public int MinionTotHealthStealth => BoardZone.Where(p => p.HasStealth).Sum(p => p.Health + p.Armor);
			public int MinionTotHealthImmune => BoardZone.Where(p => p.IsImmune).Sum(p => p.Health + p.Armor);

			public int OpHeroClassId => (int)Controller.Opponent.HeroClass;
			public int OpHeroArmor => Controller.Opponent.Hero.Armor;
			public int OpHeroBaseMana => Controller.Opponent.BaseMana;
			new public int OpMinionTotHealth => OpBoardZone.Sum(p => p.Health + p.Armor);
			new public int OpMinionTotHealthTaunt => OpBoardZone.Where(p => p.HasTaunt).Sum(p => p.Health + p.Armor);
			public int OpMinionTotHealthPoisonous => OpBoardZone.Where(p => p.Poisonous).Sum(p => p.Health + p.Armor);
			public int OpMinionWindfuryTotAtk => OpBoardZone.Where(p => p.HasWindfury).Sum(p => p.AttackDamage);
			public int OpMinionTotHealthDeathrattle => OpBoardZone.Where(p => p.HasDeathrattle).Sum(p => p.Health + p.Armor);
			public int OpMinionTotHealthDivineShield => OpBoardZone.Where(p => p.HasDivineShield).Sum(p => p.Health + p.Armor);
			public int OpMinionFrozenTotAtk => OpBoardZone.Where(p => p.IsFrozen).Sum(p => p.AttackDamage);
			public int OpMinionTotHealthStealth => OpBoardZone.Where(p => p.HasStealth).Sum(p => p.Health + p.Armor);
			public int OpMinionTotHealthImmune => OpBoardZone.Where(p => p.IsImmune).Sum(p => p.Health + p.Armor);

			List<float> Encoding = new List<float>();

			public static List<float> GetEncoding(POGame state, int playerId)
			{
				Controller p = state.CurrentPlayer.PlayerId == playerId ? state.CurrentPlayer : state.CurrentOpponent;
				return new GameStateEncoding { Controller = p }.CreateEncoding();
			}

			public List<float> CreateEncoding()
			{
				//Encoding.Add(HeroClassId);
				Encoding.Add(HeroBaseMana);
				Encoding.Add(HeroHp);
				Encoding.Add(HeroArmor);
				Encoding.Add(BoardZone.Count);
				Encoding.Add(MinionTotHealth);
				Encoding.Add(MinionTotAtk);
				Encoding.Add(MinionTotHealthTaunt);

				Encoding.Add(MinionTotHealthPoisonous);
				Encoding.Add(MinionWindfuryTotAtk);
				Encoding.Add(MinionTotHealthDeathrattle);
				Encoding.Add(MinionTotHealthDivineShield);
				Encoding.Add(MinionFrozenTotAtk);
				Encoding.Add(MinionTotHealthStealth);
				//Encoding.Add(MinionTotHealthImmune);

				//Encoding.Add(OpHeroClassId);
				Encoding.Add(OpHeroBaseMana);
				Encoding.Add(OpHeroHp);
				Encoding.Add(OpHeroArmor);
				Encoding.Add(OpBoardZone.Count);
				Encoding.Add(OpMinionTotHealth);
				Encoding.Add(OpMinionTotAtk);
				Encoding.Add(OpMinionTotHealthTaunt);

				Encoding.Add(OpMinionTotHealthPoisonous);
				Encoding.Add(OpMinionWindfuryTotAtk);
				Encoding.Add(OpMinionTotHealthDeathrattle);
				Encoding.Add(OpMinionTotHealthDivineShield);
				Encoding.Add(OpMinionFrozenTotAtk);
				Encoding.Add(OpMinionTotHealthStealth);
				//Encoding.Add(OpMinionTotHealthImmune);
				return Encoding;
			}

			public float Rate(Dictionary<string, List<double>> scoreWeights)
			{
				CreateEncoding();
				float score = 0;

				List<double> weights = scoreWeights.GetValueOrDefault(Controller.HeroClass.ToString());

				for (int i = 0; i < Encoding.Count; i++)
				{
					score += Encoding[i] * (float)weights[i];
				}
				return score;
			}
		}
	}
}
